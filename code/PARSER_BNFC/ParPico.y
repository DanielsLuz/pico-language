-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParPico where
import AbsPico
import LexPico
import ErrM

}

%name pPROGRAM PROGRAM
%name pDECLS DECLS
%name pID_TYPE_LIST ID_TYPE_LIST
%name pTYPE TYPE
%name pSERIES SERIES
%name pSTAT STAT
%name pASSIGN ASSIGN
%name pIF IF
%name pWHILE WHILE
%name pEXP EXP
%name pPLUS PLUS
%name pCONC CONC
%name pID ID
%name pID_CHARS ID_CHARS
%name pID_CHAR ID_CHAR
%name pLETTER LETTER
%name pEMPTY EMPTY
%name pListIdent ListIdent
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '+' { PT _ (TS _ 3) }
  ',' { PT _ (TS _ 4) }
  ':' { PT _ (TS _ 5) }
  ':=' { PT _ (TS _ 6) }
  ';' { PT _ (TS _ 7) }
  'begin' { PT _ (TS _ 8) }
  'declare' { PT _ (TS _ 9) }
  'do' { PT _ (TS _ 10) }
  'else' { PT _ (TS _ 11) }
  'end.' { PT _ (TS _ 12) }
  'fi' { PT _ (TS _ 13) }
  'if' { PT _ (TS _ 14) }
  'integer' { PT _ (TS _ 15) }
  'od' { PT _ (TS _ 16) }
  'string' { PT _ (TS _ 17) }
  'then' { PT _ (TS _ 18) }
  'while' { PT _ (TS _ 19) }
  '||' { PT _ (TS _ 20) }

L_integ  { PT _ (TI $$) }
L_quoted { PT _ (TL $$) }
L_charac { PT _ (TC $$) }
L_ident  { PT _ (TV $$) }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
String  :: { String }  : L_quoted {  $1 }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
Ident   :: { Ident }   : L_ident  { Ident $1 }

PROGRAM :: { PROGRAM }
PROGRAM : 'begin' DECLS SERIES 'end.' { AbsPico.PICO_PROGRAM $2 $3 }
DECLS :: { DECLS }
DECLS : 'declare' ID_TYPE_LIST ';' { AbsPico.DECLARATION0 $2 }
ID_TYPE_LIST :: { ID_TYPE_LIST }
ID_TYPE_LIST : ID ':' TYPE { AbsPico.ID_LIST0 $1 $3 }
             | ID ':' TYPE ',' ID_TYPE_LIST { AbsPico.ID_LIST1 $1 $3 $5 }
TYPE :: { TYPE }
TYPE : 'integer' { AbsPico.TYPE_INTEGER }
     | 'string' { AbsPico.TYPE_STRING }
SERIES :: { SERIES }
SERIES : EMPTY { AbsPico.SERIES0 $1 }
       | STAT ';' SERIES { AbsPico.SERIES1 $1 $3 }
STAT :: { STAT }
STAT : ASSIGN { AbsPico.STAT0 $1 }
     | IF { AbsPico.STAT1 $1 }
     | WHILE { AbsPico.STAT2 $1 }
ASSIGN :: { ASSIGN }
ASSIGN : ID ':=' EXP { AbsPico.ASSIGN0 $1 $3 }
IF :: { IF }
IF : 'if' EXP 'then' SERIES 'fi' { AbsPico.IF0 $2 $4 }
   | 'if' EXP 'then' SERIES 'else' SERIES 'fi' { AbsPico.IF1 $2 $4 $6 }
WHILE :: { WHILE }
WHILE : 'while' EXP 'do' SERIES 'od' { AbsPico.WHILE0 $2 $4 }
EXP :: { EXP }
EXP : ID { AbsPico.EXP0 $1 }
    | Integer { AbsPico.EXP1 $1 }
    | String { AbsPico.EXP2 $1 }
    | PLUS { AbsPico.EXP3 $1 }
    | CONC { AbsPico.EXP4 $1 }
    | '(' EXP ')' { AbsPico.EXP5 $2 }
PLUS :: { PLUS }
PLUS : EXP '+' EXP { AbsPico.PLUS0 $1 $3 }
CONC :: { CONC }
CONC : EXP '||' EXP { AbsPico.CONC0 $1 $3 }
ID :: { ID }
ID : LETTER ID_CHARS { AbsPico.ID0 $1 $2 }
   | ID_CHARS { AbsPico.ID1 $1 }
ID_CHARS :: { ID_CHARS }
ID_CHARS : ID_CHAR ID_CHARS { AbsPico.ID_CHARS1 $1 $2 }
         | EMPTY { AbsPico.ID_CHARS2 $1 }
ID_CHAR :: { ID_CHAR }
ID_CHAR : LETTER { AbsPico.ID_CHAR1 $1 }
LETTER :: { LETTER }
LETTER : Char { AbsPico.LETTERS $1 }
EMPTY :: { EMPTY }
EMPTY : ListIdent { AbsPico.EMPTY0 $1 }
ListIdent :: { [Ident] }
ListIdent : {- empty -} { [] } | Ident ListIdent { (:) $1 $2 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

